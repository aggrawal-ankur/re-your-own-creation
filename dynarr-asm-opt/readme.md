# Optimizing dynarr.asm

***Date: February 03, 2026***

Now I've a fully working handwritten assembly for dynarr.asm. The next thing I want to do is to understand the various optimization tricks that can be applied on this assembly and implement them.

I don't have to do any guess-work because I can take help from GCC itself. I'll read, analyze and understand GCC's output at -O1 and -O2 and implement those tricks in my assembly. That's my next target.

My approach is simple.

First, I don't know if there is a canonical source where every compiler optimization term is mentioned. I am not going to cry this time. Doesn't exist, great.

Second, even if there was a canonical source, or I get one generated by ChatGPT, reading that would feel boring because I don't know how the shape of assembly changes when that optimization trick is applied on baseline assembly.

My approach is that I'll generate -O1 and -O2 assembly from GCC and analyze every procedure line by line, understand how the intent is expressed here and how is it different from my handwritten assembly.

Next I'll feed my analysis and gcc's output to ChatGPT, because ChatGPT has knowledge that I don't have, plus it can access internet quickly. ChatGPT will name the **compiler optimization term** involved here.

If I were to optimize GCC's -O0 output, that'd have felt boring and non-living. I've already removed that by writing a baseline assembly myself. Now it will feel extremely personal and related, something I need when I want to make real progress.

I don't know how I will manage the findings, so I am letting findings come first. Later, the solutions will emerge too.

Thoughts here will be raw, except the technical stuff, which is either correct or incorrect, nothing in between.

## GCC Output

```bash
gcc dynarr/dynarr.c -S -masm=intel -O1 -fno-asynchronous-unwind-tables -fno-dwarf2-cfi-asm -masm=intel
```

Line stats: 483

# First Impressions (Day 1)

I've 2 immediate findings.
  1. Base pointer omission
  2. Different offset calculation method

Base pointer omission is something I'm aware of.

## Offset calculation

Since the layout of the dynamic array is simple and consistent, there is no need for calculations like: `[rdi + 8*1]`. GCC is using:
```asm
mov	QWORD PTR [r12], rax
mov	QWORD PTR 8[r12], rbx
mov	QWORD PTR 24[r12], rbp
mov	QWORD PTR 16[r12], 0
```
.... throughout the assembly.

I have used stuff like: `[rdi + 8*1]`, which is better to comprehend the layout when you are a newbie. When I was starting, I've to think like: "0-7 for ptr, 8-15 for elem_size, so [rdi + 8*1] is the right one".

When I look at GCC's version, I can immediate notice that it is better. `8[rdi]` is basically elem_size. It aligns with how I started myself to reason offset calculation in organized memory layouts. `QWORD PTR 8[rdi]` means "load 8 bytes starting from 8th byte from the base represented by rdi".

That's the first thing I am going to change.

### After math

I've made the changes and running the tests again showed that pushOne had a segfault, which means memcpy failed. init and extend worked as expected.

This line was wrong:
```asm
mov  rdi, QWORD PTR  8[r14]    # arr->ptr

# Correct one
mov  rdi, QWORD PTR   [r14]    # arr->ptr
```

That means, I wrongly updated one pattern for address calculation.

pushOne works now and pushMany is fine. getelement is the next wrong piece, a segfault. I presume the same problem, and it is.
```asm
mov  rax, QWORD PTR 8[r14]    # arr->ptr

# Correct one
mov  rdi, QWORD PTR  [r14]    # arr->ptr
```

getelement is working, setidx is working, the next segfault is at mergedyn2dyn. It should be at memcpy and I presume the same issue, and it is. All tests passed.

## Base Pointer Omission

For this kind of stuff, I am gonna use my [knowledge-base](https://github.com/aggrawal-ankur/knowledge-base), which is also available on GitHub. It has been a long time updating it.

**IMPORTANT NOTE: It already contains a directory for compiler optimizations which has tables I generated with ChatGPT when I was attempting to learn compiler optimization terms during Nov 21, 2025 to Dec 21, 2025. I will clear that stuff before I add anything.**

**IMPORTANT NOTE: I've removed 6/7 files as the last one is literally about FPO only. Although it contains mostly unnecessary stuff and I've removed that part.**

It can be found here: [compiler-optimizations/fpo.md](https://github.com/aggrawal-ankur/knowledge-base/blob/main/compiler-optimizations/fpo/fpo.md)

---

BPO/FPO implemented. 47 lines reduced, builds, runs, and passes all tests.

---

Done with the day.

# Day 2

***February 04, 2026***