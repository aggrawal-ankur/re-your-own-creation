# Optimizing dynarr.asm

***Date: February 03, 2026***

Now I've a fully working handwritten assembly for dynarr.asm. The next thing I want to do is to understand the various optimization tricks that can be applied on this assembly and implement them.

I don't have to do any guess-work because I can take help from GCC itself. I'll read, analyze and understand GCC's output at -O1 and -O2 and implement those tricks in my assembly. That's my next target.

My approach is simple.

First, I don't know if there is a canonical source where every compiler optimization term is mentioned. I am not going to cry this time. Doesn't exist, great.

Second, even if there was a canonical source, or I get one generated by ChatGPT, reading that would feel boring because I don't know how the shape of assembly changes when that optimization trick is applied on baseline assembly.

My approach is that I'll generate -O1 and -O2 assembly from GCC and analyze every procedure line by line, understand how the intent is expressed here and how is it different from my handwritten assembly.

Next I'll feed my analysis and gcc's output to ChatGPT, because ChatGPT has knowledge that I don't have, plus it can access internet quickly. ChatGPT will name the **compiler optimization term** involved here.

If I were to optimize GCC's -O0 output, that'd have felt boring and non-living. I've already removed that by writing a baseline assembly myself. Now it will feel extremely personal and related, something I need when I want to make real progress.

I don't know how I will manage the findings, so I am letting findings come first. Later, the solutions will emerge too.
